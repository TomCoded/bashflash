A probability space is a tuple (Capital-Omega, F, P) where Omega is a sample space (the set of all possible outcomes), F is a set of events where each event is a set containing zero or more outcomes, and P is a function from events to probabilities. If an outcome occurs after an iteration of your model, all events in F are said to have occurred. If you iterate infinitely, each event will occur with the probability described by P. F is a sigma algebra.
A sigma algebra (also called a sigma-field) on a set X is a collection capital-sigma of subsets of of X that include the empty subset, is closed under complement, countable unions, and countable intersections. The pair (X, capital-sigma), i.e. a set a sigma algebra on it, is called a "measurable space" or "Borel space"
The free energy theory: Active Inference rests on the tuple (capital-omega, capital-Psi, S, A, R, q, p). They are (sample space, Hidden or External States Psi x A x OMEGA => |R that cause sensory states and depend on action, Action A: S x R => |R that depends on sensory and internal states, Internal States R: R x S => |R that cause action and depend on sensory states, generative density p over sensory and hidden states under a generative model m, and variational density q over hidden states _psi from PSI that is paramterized by internal states mu from R. The obvective is to minimize surprise.
Markov blankets... (? some see all biological and perhaps nonbiological systems as organizing themselves this way... see a markov blanket around everything from part of a NN to a cherry tree)
The sum of a geometric sequence, i.e. a sequence from 0 to n-1 of a*r^k, is shown in closed form by multiplying the resulting polynomial by r and subtracting it from the initial polynomial. The result simplifies to a(1-r^n)/(1-r).  More generally, a geometric sequence starting at m and ending at n, i.e. the sum over k for k in the range of m to n of a*r^k, is a(r^m-r^(n+1))/(1-r)
Any polynomial can be expressed as a power series around any center.
A power series takes the form the sum of 1 to infinity of a_n * (x-c) ^ n, where c is a "center" (if describing a polynomial) or a constant (generally). a_n is not necessarily a constant and usually isn't. Negative powers are NOT permitted in a power series.
When two power series f() and g() are decomposed into power series around the same center, the power series of the sum or difference can be obtained by termwise addition and subtraction.
A function f is defined on an open subset U of R or C is called analytic if it is locally given by a convergent power series. This means every a contained in U has an open neighborhood V subset of U s.t. there exists a power series with a center that converges to f(x) for every x contained in V.
Carter and Wegman's original hash function proposal for universal hashing was ((ax + b ) mod p) mod m, for a and b random integers, p is a prime >= m.
A simple and almost universal hash is (ax mod p) mod m, where a is a random integer and p is a prime >= m.
A simple and almost universal hash that AVOIDS MODULAR ARITHMATIC and is therefore 4x as fast is h_a(x) = (ax mod 2^w) div 2^(w-M) = (size_t) (a*x) >> (w-M). Assumes the number of bins is a power of 2, m=2^M. w is the number of bits in a word. Multiply x by a<2^w and keep the M high-order bits.
A linear recurrence is just a recurrence that is a linear combination of a fixed number of lesser terms, e.g. f(n)=SUM over i from fixed start to fixed d of (a_i * f(n-i)) where a_i is a constant. E.g. the fibonnaci recurrence is just f(n) = 1*f(n-1) + 1*f(n-2). d is the "order" of the linear recurrence, so for example the Fibonnaci recurrence is a second order linear recurrence. LINEAR recurrences have n-1, n-2, etc... form for this. (So divide-and-conquer are NOT linear, since have a/b form)
The Fibonnaci recurrence was described by Fibonnacci in around 1208, used as a model for rabbit populations, but Indian mathematicians were actually playing with it around 200 B.C. I believe.
If f(n) = a^n and f(n)= a_2^n are solutions to a linear recurrence (ignoring the boundary conditions), then any linear combination of them is ALSO a solution to them.
The closed form for the fibonnaci sequence is derived from using the quadratic formula on its linear recurrence and then deriving the appropriate constants to use from the base cases. For the standard fibonnaci sequence, the closed form is (1/sqrt(5)) * ((1 + sqrt(5)/2)^n) - (1/sqrt(5)) * ((1 - sqrt(5)/2)^n). Took the europeans 600 years to figure it out.
Solving a linear recurrence for a HOMOGENOUS (i.e. can be set equal to zero to solve / no nonlinear terms) is just about figuring out what values and constants in an equation will give you a closed form. You do this by solving the "characteristic equation", which means you create a polynomial of degree n-d by substituting alpha^n as the value of T(n), subtracting the RHS of the equation from T(n), dividing through by the lowest remaining alpha^n. Find the roots. Then substitute the roots as the value of alpha in your alpha^n guess, e.g. T(n) = SUM of c_k*ROOT^n over each root, and if you have enough boundary conditions to solve for the constants then you have a closed form for the recurrence relation. So for T(n) = 2T(n-1), characteristic polynomial is a-2=0, root is 2, and t(n) = c_1*2^n. Mechanically, to get the characteristic equation for a linear recurrence, change the subscripts to exponents, change the variable name to your unknown (e.g. x), divide through by the smallest exponent. 
To solve a linear recurrence for a NON-HOMOGENOUS recurrence (e.g. T(n) = aT(n-1) - g(n), solve the homogenous part first ignoring boundary conditions, then solve a particular case of the non-homogenous one ignoring boundary conditions, then add those solutions together and solve for your unknown constants. For solving particular cases, you have to guess f(n) to be a value related to g(n). If the guess doesn't work, you try other guesses. Keep pounding with another factor of n in front. 
